#pragma once

#include "type_traits"

namespace vl
{

template <class T>
inline T&& forward(typename vl::remove_reference<T>::type& t) noexcept
{
    return static_cast<T&&>(t);
}

template <class T>
inline T&& forward(typename vl::remove_reference<T>::type&& t) noexcept
{
    static_assert(!vl::is_lvalue_reference<T>::value,
                  "Can not forward an rvalue as an lvalue.");
    return static_cast<T&&>(t);
}

}