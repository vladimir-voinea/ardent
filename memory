#pragma once

namespace vl
{

template <typename T>
class unique_ptr
{
public:
    unique_ptr()
        : data(nullptr)
    {}
    // Explicit constructor
    explicit unique_ptr(T* data)
        : data(data)
    {}
    ~unique_ptr()
    {
        delete data;
    }

    // Constructor/Assignment that binds to nullptr
    // This makes usage with nullptr cleaner
    unique_ptr(std::nullptr_t)
        : data(nullptr)
    {}

    unique_ptr& operator=(std::nullptr_t)
    {
        reset();
        return *this;
    }

    // Constructor/Assignment that allows move semantics
    unique_ptr(unique_ptr&& moving) noexcept
        : data(nullptr)
    {
        moving.swap(*this);
        // In the comments it was pointed out that this
        // does not match the implementation of std::unique_ptr
        // I am going to leave mine the same. But
        // the the standard provides some extra guarantees
        // and probably a more intuitive usage.
    }
    unique_ptr& operator=(unique_ptr&& moving) noexcept
    {
        moving.swap(*this);
        return *this;
        // See move constructor.
    }

    // Constructor/Assignment for use with types derived from T
    template<typename U>
    unique_ptr(unique_ptr<U>&& moving)
    {
        unique_ptr<T>   tmp(moving.release());
        tmp.swap(*this);
    }
    template<typename U>
    unique_ptr& operator=(unique_ptr<U>&& moving)
    {
        unique_ptr<T>    tmp(moving.release());
        tmp.swap(*this);
        return *this;
    }

    // Remove compiler generated copy semantics.
    unique_ptr(unique_ptr const&)            = delete;
    unique_ptr& operator=(unique_ptr const&) = delete;

    // Const correct access owned object
    T* operator->() const {return data;}
    T& operator*()  const {return *data;}

    // Access to smart pointer state
    T* get()                 const {return data;}
    explicit operator bool() const {return data;}

    // Modify object state
    T* release() noexcept
    {
        T* result = nullptr;
        std::swap(result, data);
        return result;
    }

    void swap(unique_ptr& src) noexcept
    {
        std::swap(data, src.data);
    }

    void reset()
    {
        T* tmp = release();
        delete tmp;
    }

private:
    T*   data;
};

template <typename T>
void swap(unique_ptr<T>& lhs, unique_ptr<T>& rhs)
{
    lhs.swap(rhs);
}

}